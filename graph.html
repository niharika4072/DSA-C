<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="graph.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <title>Graphs</title>
    <style>
        pre{
            text-align: left;
        }
    </style>
    <body>
        <header>
            <div class="logo">
                <h1>Programming Hub</h1>
            </div>
            <nav>
                <ul class="navv">
                    <li><a href="index.html"><i class="fas fa-home"></i> Home</a></li>
                    <li><a href="loginform.html"><i class="fas fa-envelope"></i> Contact Us</a></li>
                </ul>
            </nav>
        </header>
    <div class="container">
        <!-- Left Navigation Bar -->
        <nav class="navbar">
            <ul class="navlist">
                <li><a href="2D array.html">2D Array</a></li>
                <li><a href="graph.html">Graph</a></li>
                <li><a href="LL.html">Linked List</a></li>
                <li><a href="queues.html">Queue</a></li>
                <li><a href="trees.html">Tree</a></li>
                <li><a href="recursion.html">Recursion</a></li>
                <li><a href="searchingalgo.html">Searching Algorithm</a></li>
                <li><a href="singleDarray.html">Single Dimension Array</a></li>
                <li><a href="sortingalgo.html">Sorting Algorithm</a></li>
                <li><a href="Stacks.html">Stack</a></li>
                <li><a href="string.html">Strings</a></li>
                <li><a href="trees.html">Tree</a></li>
            </ul>
        </nav> 

        <!-- Right Main Content -->
        <section class="main-content">
            <div class="box-main">
                <h1 style="text-align: center;"><b>Graphs</b></h1>
                <div class="overview">
                    <p>In data structures, a graph is a collection of nodes (or vertices) connected by 
                        edges. Graphs are highly versatile structures, allowing representation of 
                        various real-world problems, such as social networks, transport systems, and 
                        computer networks.
                    </p>
                    <h3 style="margin-bottom: 15px;">Basic components of Graphs</h3>
                    <ul class="structure" style="line-height: 23px; margin-left: 25px;">
                        <li><b>Vertices(nodes):</b> The entities or points in the graph.</li>
                        <li><b>Edges(Links):</b> Connections between vertices, representing relationships or paths.</li>
                        <li><b>Degree of a vertex:</b> The number of edges connected to a vertex. </li>
                    </ul>
                    <h3>Types of Graphs</h3>
                    <br>
                    <ul style="line-height: 20px; margin-left: 25px;" class="structure">
                        <li><b>Undirected Graph:</b> The edges have no direction, meaning the connection between nodes is bidirectional.</li>
                        <li><b>Directed Graph:</b>  Each edge has a direction, going from one vertex to another (unidirectional).</li>
                        <br>
                        <li><b>Weighted Graph:</b> Edges have weights or costs associated with them, representing quantities like distance, time, or cost.</li>
                        <li><b>Unweighted Graph:</b> All edges have the same or no weight.</li>
                        <br>
                        <li><b>Connected Graph:</b> In undirected graphs, there is a path between every pair of vertices</li>
                        <li><b>Disconnected Graph:</b> Not all vertices are reachable from every other vertex.</li>
                        <br>
                        <li><b>Simple Graphs:</b> It is an undirected graph with no loops and no more than one edge between any pair of vertices.</li>
                        <li><b>Multigraph:</b> It is a graph that allows multiple edges between the same pair of vertices and may include loops.</li>
                    </ul>
                    <h3>Graph Traversal Techniques</h3>
                    <p style="line-height: 30px;">Traversal is the process of visiting nodes in a graph systematically. Common traversal methods include:</p>
                    <ul style="line-height: 20px; margin-left: 25px;" class="structure">
                        <li><b>Depth-First Search(DFS):</b> Explores as deep as possible along a branch before backtracking. It uses a stack (or recursion) to keep track of nodes.</li>
                            <ul style="margin-left: 40px;">
                                <li><b>Applications:</b> Detecting cycles, pathfinding, topological sorting.</li>
                            </ul>
                        <li style="margin-top: 10px;"><b>Breadth-First Search (BFS):</b> Explores all neighbors of a vertex before moving to the next level of vertices. It uses a queue to keep track of nodes.</li>
                            <ul style="margin-left: 40px;">
                                <li><b>Applications:</b> Shortest path in unweighted graphs, level order traversal.</li>
                            </ul>
                    </ul>
                    <h3>Applications of Graphs</h3>
                    <ul style="margin-top: 20px; line-height: 23px;" class="structure">
                        <li><b>Social Networks:</b> Represents people as vertices and relationships as edges.</li>
                        <li><b>Routing and Navigation:</b> Used in GPS and network routing algorithms.</li>
                        <li><b>Web Crawling:</b> Pages are vertices, and hyperlinks are directed edges.</li>
                        <li><b>Dependency Resolution:</b> Compilers use graphs to resolve dependencies among modules.</li>
                    </ul>
                    <br>
                    <h2><b>Here are some codes related to Graphs</b></h2>
                    <br>
                        <div class="box-ques">
                                <ul>
                                    <li><a href="#2Q1">1. Enter the vertices and edges and represent in Adjacency Matrix and print it.</a></li>
                                    <li><a href="#2Q2">2. Create the Graph as an adjacency List with operations such as insertion and deletion.</a></li>
                                    <li><a href="#2Q3">3. Traverse the Adjacency Matrix with depth First Search(DFS).</a></li>
                                    <li><a href="#2Q4">4. Traverse the Adjacent List with Depth First Search(DFS).</a></li>
                                    <li><a href="#2Q5">5. Traverse the Adjacent Matrix with Breadth First Search(BFC).</a></li>
                                    <li><a href="#2Q6">6. Traverse the Adjacent List with Breadth First Search(BFS).</a></li>            
                        </div>



    <pre>
<br>
<b id="2Q1">1. ENTER THE VERTICES AND EDGES AND REPRESENT IN ADJACENCY MATRIX AND PRINT IT ?</b> 

#include &lt;stdio.h&gt;

int main() {
int vertices, edges;

printf("Enter the number of vertices in the graph: ");
scanf("%d", &vertices);

printf("Enter the number of edges in the graph: ");
scanf("%d", &edges);

int adjacencyMatrix[vertices][vertices];

for (int i = 0; i &lt; vertices; i++) {
    for (int j = 0; j &lt; vertices; j++) {
        adjacencyMatrix[i][j] = 0;
    }
}

for (int i = 0; i &lt; edges; i++) {
    int source, destination;
    printf("Enter edge %d (source destination): ", i + 1);
    scanf("%d %d", &source, &destination);

    if (source &gt;= 0 && source &lt; vertices && destination &gt;= 0 && destination &lt; vertices) {
        adjacencyMatrix[source][destination] = 1;
        adjacencyMatrix[destination][source] = 1;
    } else {
        printf("Invalid vertex indices. Please enter valid indices.\n");
        i--;
    }
}

printf("Adjacency Matrix:\n");
for (int i = 0; i &lt; vertices; i++) {
    for (int j = 0; j &lt; vertices; j++) {
        printf("%d ", adjacencyMatrix[i][j]);
    }
    printf("\n");
}

return 0;
}

</pre>
    <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

Enter the number of vertices in the graph: 3
Enter the number of edges in the graph: 3
Enter edge 1 (source destination): 0 1
Enter edge 2 (source destination): 1 2
Enter edge 3 (source destination): 0 2
Adjacency Matrix:
0 1 1 
1 0 1 
1 1 0 
    

</pre>

    <pre>
<br>
<b id="2Q2">2. CREATE THE GRAPH AS A ADJACENCY LIST WITH OPERATIONS SUCH AS INSERTION, DELETION ?</b> 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
int data;
struct Node* next;
};

struct Graph {
int V;
struct Node** adjList;
};

struct Node* createNode(int data) {
struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
newNode-&gt;data = data;
newNode-&gt;next = NULL;
return newNode;
}

struct Graph* createGraph(int V) {
struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
graph-&gt;V = V;
graph-&gt;adjList = (struct Node**)malloc(V * sizeof(struct Node*));

for (int i = 0; i &lt; V; i++) {
    graph-&gt;adjList[i] = NULL;
}

return graph;
}

void addEdge(struct Graph* graph, int src, int dest) {
struct Node* newNode = createNode(dest);
newNode-&gt;next = graph-&gt;adjList[src];
graph-&gt;adjList[src] = newNode;

newNode = createNode(src);
newNode-&gt;next = graph-&gt;adjList[dest];
graph-&gt;adjList[dest] = newNode;
}

void deleteEdge(struct Graph* graph, int src, int dest) {
struct Node* current = graph-&gt;adjList[src];
struct Node* prev = NULL;

while (current != NULL && current-&gt;data != dest) {
    prev = current;
    current = current-&gt;next;
}

if (current == NULL) {
    return;
}

if (prev == NULL) {
    graph-&gt;adjList[src] = current-&gt;next;
} else {
    prev-&gt;next = current-&gt;next;
}

free(current);

current = graph-&gt;adjList[dest];
prev = NULL;

while (current != NULL && current-&gt;data != src) {
    prev = current;
    current = current-&gt;next;
}

if (prev == NULL) {
    graph-&gt;adjList[dest] = current-&gt;next;
} else {
    prev-&gt;next = current-&gt;next;
}

free(current);
}

void displayGraph(struct Graph* graph) {
for (int i = 0; i &lt; graph-&gt;V; i++) {
    struct Node* current = graph-&gt;adjList[i];
    printf("Adjacency list of vertex %d: ", i);
    while (current != NULL) {
        printf("%d -&gt; ", current-&gt;data);
        current = current-&gt;next;
    }
    printf("NULL\n");
}
}

int main() {
int V, E;

printf("Enter the number of vertices: ");
scanf("%d", &V);

struct Graph* graph = createGraph(V);

printf("Enter the number of edges: ");
scanf("%d", &E);

for (int i = 0; i &lt; E; i++) {
    int src, dest;
    printf("Enter edge %d (source destination): ", i + 1);
    scanf("%d %d", &src, &dest);
    addEdge(graph, src, dest);
}

printf("Graph before deletion:\n");
displayGraph(graph);

int src, dest;
printf("Enter edge to delete (source destination): ");
scanf("%d %d", &src, &dest);
deleteEdge(graph, src, dest);

printf("Graph after deletion:\n");
displayGraph(graph);

return 0;
}


</pre>
    <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>

Enter the number of vertices: 4
Enter the number of edges: 4
Enter edge 1 (source destination): 0 1
Enter edge 2 (source destination): 0 2
Enter edge 3 (source destination): 1 2
Enter edge 4 (source destination): 2 3
Graph before deletion:
Adjacency list of vertex 0: 2 -&gt; 1 -&gt; NULL
Adjacency list of vertex 1: 2 -&gt; 0 -&gt; NULL
Adjacency list of vertex 2: 3 -&gt; 1 -&gt; 0 -&gt; NULL
Adjacency list of vertex 3: 2 -&gt; NULL
Enter edge to delete (source destination): 0 1
Graph after deletion:
Adjacency list of vertex 0: 2 -&gt; NULL
Adjacency list of vertex 1: NULL
Adjacency list of vertex 2: 3 -&gt; NULL
Adjacency list of vertex 3: 2 -&gt; NULL

        
</pre>

    <pre>
<br>
<b id="2Q3">3. TRAVERSE THE ADJACENT MATRIX WITH DEPTH FIRST SEARCH ?</b>

#include &lt;stdio.h&gt;

void depthFirstSearch(int vertex, int V, int adjacencyMatrix[V][V], int visited[]) {
printf("%d ", vertex);
visited[vertex] = 1;

for (int i = 0; i &lt; V; i++) {
    if (adjacencyMatrix[vertex][i] == 1 && !visited[i]) {
        depthFirstSearch(i, V, adjacencyMatrix, visited);
    }
}
}

int main() {
int V;

printf("Enter the number of vertices: ");
scanf("%d", &V);

int adjacencyMatrix[V][V];

printf("Enter the adjacency matrix (%d x %d):\n", V, V);
for (int i = 0; i &lt; V; i++) {
    for (int j = 0; j &lt; V; j++) {
        scanf("%d", &adjacencyMatrix[i][j]);
    }
}

int visited[V];
for (int i = 0; i &lt; V; i++) {
    visited[i] = 0;
}

printf("Enter the starting vertex for DFS: ");
int startVertex;
scanf("%d", &startVertex);

printf("Depth-First Search Traversal starting from vertex %d: ", startVertex);
depthFirstSearch(startVertex, V, adjacencyMatrix, visited);
printf("\n");

return 0;
}


    </pre>
    <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3> 
    
Enter the number of vertices: 4
Enter the adjacency matrix (4 x 4):
0 1 0 1
1 0 1 0
0 1 0 0
1 0 0 0
Enter the starting vertex for DFS: 0
Depth-First Search Traversal starting from vertex 0: 0 1 2 3 

</pre>

    <pre>
<br>
<b id="2Q4">4. TRAVERSE THE ADJACENT LIST WITH DEPTH FIRST SEARCH ?</b> 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
int data;
struct Node* next;
};

struct Graph {
int V;
struct Node** adjList;
};

struct Node* createNode(int data) {
struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
newNode->data = data;
newNode->next = NULL;
return newNode;
}

struct Graph* createGraph(int V) {
struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
graph->V = V;
graph->adjList = (struct Node**)malloc(V * sizeof(struct Node*));

for (int i = 0; i &lt; V; i++) {
    graph->adjList[i] = NULL;
}

return graph;
}

void addEdge(struct Graph* graph, int src, int dest) {
struct Node* newNode = createNode(dest);
newNode-&gt;next = graph->adjList[src];
graph->adjList[src] = newNode;

newNode = createNode(src);
newNode-&gt;next = graph->adjList[dest];
graph->adjList[dest] = newNode;
}

void depthFirstSearch(struct Graph* graph, int vertex, int visited[]) {
visited[vertex] = 1;
printf("%d ", vertex);

struct Node* current = graph->adjList[vertex];
while (current != NULL) {
    if (!visited[current->data]) {
        depthFirstSearch(graph, current->data, visited);
    }
    current = current->next;
}
}

int main() {
int V, E;

printf("Enter the number of vertices: ");
scanf("%d", &V);

struct Graph* graph = createGraph(V);

printf("Enter the number of edges: ");
scanf("%d", &E);

for (int i = 0; i &lt; E; i++) {
    int src, dest;
    printf("Enter edge %d (source destination): ", i + 1);
    scanf("%d %d", &src, &dest);
    addEdge(graph, src, dest);
}

printf("Enter the starting vertex for DFS: ");
int startVertex;
scanf("%d", &startVertex);

int visited[V];
for (int i = 0; i &lt; V; i++) {
    visited[i] = 0;
}

printf("Depth-First Search Traversal starting from vertex %d: ", startVertex);
depthFirstSearch(graph, startVertex, visited);
printf("\n");

return 0;
}


    </pre>
    <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>
    
Enter the number of vertices: 5
Enter the number of edges: 4
Enter edge 1 (source destination): 0 1
Enter edge 2 (source destination): 0 4
Enter edge 3 (source destination): 1 3
Enter edge 4 (source destination): 1 2
Enter the starting vertex for DFS: 0
Depth-First Search Traversal starting from vertex 0: 0 1 3 2 4 

</pre>

    <pre>
<br>
<b id="2Q5">5. TRAVERSE THE ADJACENT MATRIX WITH BREADTH FIRST SEARCH ?</b> 

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void breadthFirstSearch(int startVertex, int V, int adjacencyMatrix[V][V], int visited[]) {
int queue[V];
int front = -1, rear = -1;

printf("Breadth-First Search Traversal starting from vertex %d: ", startVertex);

visited[startVertex] = 1;
queue[++rear] = startVertex;

while (front != rear) {
    int currentVertex = queue[++front];
    printf("%d ", currentVertex);

    for (int i = 0; i &lt; V; i++) {
        if (adjacencyMatrix[currentVertex][i] == 1 && !visited[i]) {
            visited[i] = 1;
            queue[++rear] = i;
        }
    }
}

printf("\n");
}

int main() {
int V;

printf("Enter the number of vertices: ");
scanf("%d", &V);

int adjacencyMatrix[V][V];

printf("Enter the adjacency matrix (%d x %d):\n", V, V);
for (int i = 0; i &lt; V; i++) {
    for (int j = 0; j &lt; V; j++) {
        scanf("%d", &adjacencyMatrix[i][j]);
    }
}

int visited[V];
for (int i = 0; i &lt; V; i++) {
    visited[i] = 0;
}

int startVertex;
printf("Enter the starting vertex for BFS: ");
scanf("%d", &startVertex);

breadthFirstSearch(startVertex, V, adjacencyMatrix, visited);

return 0;
}


    </pre>
    <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>  

Enter the number of vertices: 5
Enter the adjacency matrix (5 x 5):
0 1 0 0 1
1 0 1 1 0
0 1 0 0 0
0 1 0 0 0
1 0 0 0 0
Enter the starting vertex for BFS: 0
Breadth-First Search Traversal starting from vertex 0: 0 1 4 2 3 


</pre>

    <pre>
<br>
<b id="2Q6">6. TRAVERSE THE ADJACENT LIST WITH BREADTH FIRST SEARCH ?</b>

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
int data;
struct Node* next;
};

struct Graph {
int V;
struct Node** adjList;
};

struct Node* createNode(int data) {
struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
newNode->data = data;
newNode->next = NULL;
return newNode;
}

struct Graph* createGraph(int V) {
struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
graph->V = V;
graph->adjList = (struct Node**)malloc(V * sizeof(struct Node*));

for (int i = 0; i &lt; V; i++) {
    graph->adjList[i] = NULL;
}

return graph;
}

void addEdge(struct Graph* graph, int src, int dest) {
struct Node* newNode = createNode(dest);
newNode-&gt;next = graph->adjList[src];
graph->adjList[src] = newNode;

newNode = createNode(src);
newNode-&gt;next = graph->adjList[dest];
graph->adjList[dest] = newNode;
}

void breadthFirstSearch(struct Graph* graph, int startVertex, int visited[]) {
int queue[graph->V];
int front = -1, rear = -1;

printf("Breadth-First Search Traversal starting from vertex %d: ", startVertex);

visited[startVertex] = 1;
queue[++rear] = startVertex;

while (front != rear) {
    int currentVertex = queue[++front];
    printf("%d ", currentVertex);

    struct Node* current = graph->adjList[currentVertex];
    while (current != NULL) {
        if (!visited[current->data]) {
            visited[current->data] = 1;
            queue[++rear] = current->data;
        }
        current = current-&gt;next;
    }
}

printf("\n");
}

int main() {
int V, E;

printf("Enter the number of vertices: ");
scanf("%d", &V);

struct Graph* graph = createGraph(V);

printf("Enter the number of edges: ");
scanf("%d", &E);

for (int i = 0; i &lt; E; i++) {
    int src, dest;
    printf("Enter edge %d (source destination): ", i + 1);
    scanf("%d %d", &src, &dest);
    addEdge(graph, src, dest);
}

int visited[V];
for (int i = 0; i &lt; V; i++) {
    visited[i] = 0;
}

int startVertex;
printf("Enter the starting vertex for BFS: ");
scanf("%d", &startVertex);

breadthFirstSearch(graph, startVertex, visited);

return 0;
}


    </pre>
    <pre class="out">
<h3 style="text-align: center;">OUTPUT</h3>  

Enter the number of vertices: 5
Enter the number of edges: 4
Enter edge 1 (source destination): 0 1
Enter edge 2 (source destination): 0 4
Enter edge 3 (source destination): 1 2
Enter edge 4 (source destination): 1 3
Enter the starting vertex for BFS: 0
Breadth-First Search Traversal starting from vertex 0: 0 1 4 2 3 


</pre>
       

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();

        // Get the button
        const backToTopBtn = document.getElementById("backToTopBtn");

        // Show or hide the button based on scroll position
        window.onscroll = function () {
            if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
                backToTopBtn.style.display = "block";
            } else {
                backToTopBtn.style.display = "none";
            }
        };
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add("fade-in");
                }
            });
        });
        document.querySelectorAll(".topic-section").forEach(section => {
            observer.observe(section);
        });
    </script>
</body>
</html>
